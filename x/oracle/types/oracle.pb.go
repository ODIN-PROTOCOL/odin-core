// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oracle/v1/oracle.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ResolveStatus encodes the status of an oracle request.
type ResolveStatus int32

const (
	// Open - the request is not yet resolved.
	RESOLVE_STATUS_OPEN ResolveStatus = 0
	// Success - the request has been resolved successfully with no errors.
	RESOLVE_STATUS_SUCCESS ResolveStatus = 1
	// Failure - an error occured during the request's resolve call.
	RESOLVE_STATUS_FAILURE ResolveStatus = 2
	// Expired - the request does not get enough reports from validator within the
	// timeframe.
	RESOLVE_STATUS_EXPIRED ResolveStatus = 3
)

var ResolveStatus_name = map[int32]string{
	0: "RESOLVE_STATUS_OPEN_UNSPECIFIED",
	1: "RESOLVE_STATUS_SUCCESS",
	2: "RESOLVE_STATUS_FAILURE",
	3: "RESOLVE_STATUS_EXPIRED",
}

var ResolveStatus_value = map[string]int32{
	"RESOLVE_STATUS_OPEN_UNSPECIFIED": 0,
	"RESOLVE_STATUS_SUCCESS":          1,
	"RESOLVE_STATUS_FAILURE":          2,
	"RESOLVE_STATUS_EXPIRED":          3,
}

func (x ResolveStatus) String() string {
	return proto.EnumName(ResolveStatus_name, int32(x))
}

func (ResolveStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{0}
}

// DataSource is the data structure for storing data sources in the storage.
type DataSource struct {
	// Owner is an address of the account who own the data source
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// Name is data source name used for display
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description is data source description used for display
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Filename is string of file name used as reference for locating
	// data source file stored in odinchain nodes
	Filename string `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	// Treasury is the account address who receive data source fee from requester.
	Treasury string `protobuf:"bytes,5,opt,name=treasury,proto3" json:"treasury,omitempty"`
	// Fee is the data source fee per ask_count that data provider will receive
	// from requester.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
}

func (m *DataSource) Reset()         { *m = DataSource{} }
func (m *DataSource) String() string { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()    {}
func (*DataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{0}
}
func (m *DataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSource.Merge(m, src)
}
func (m *DataSource) XXX_Size() int {
	return m.Size()
}
func (m *DataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSource.DiscardUnknown(m)
}

var xxx_messageInfo_DataSource proto.InternalMessageInfo

func (m *DataSource) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DataSource) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *DataSource) GetTreasury() string {
	if m != nil {
		return m.Treasury
	}
	return ""
}

func (m *DataSource) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

// OracleScript is the data structure for storing oracle scripts in the storage.
type OracleScript struct {
	// Owner is an address of the account who own the oracle script
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// Name is oracle script name used for display
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description is oracle script description used for display
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Filename is string of file name used as reference for locating
	// compiled oracle script WASM file stored in odinchain nodes
	Filename string `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	// Schema is the schema of the oracle script input/output
	// which is formatted in OBI format e.g.
	// "{symbol:string,multiplier:u64}/{px:u64}"
	Schema string `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	// SourceCodeURL is the URL of oracle script's source code.
	// It is recommendded to store source code on IPFS and get its URL to preserve
	// decentralization.
	SourceCodeURL string `protobuf:"bytes,6,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
}

func (m *OracleScript) Reset()         { *m = OracleScript{} }
func (m *OracleScript) String() string { return proto.CompactTextString(m) }
func (*OracleScript) ProtoMessage()    {}
func (*OracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{1}
}
func (m *OracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleScript.Merge(m, src)
}
func (m *OracleScript) XXX_Size() int {
	return m.Size()
}
func (m *OracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_OracleScript proto.InternalMessageInfo

func (m *OracleScript) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *OracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OracleScript) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *OracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *OracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

// RawRequest is the data structure for storing raw requests in the storage.
type RawRequest struct {
	// ExternalID is an ID of the raw request
	ExternalID ExternalID `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	// DataSourceID is an ID of data source script that relates to the raw request
	DataSourceID DataSourceID `protobuf:"varint,2,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
	// Calldata is the data used as argument params for executing data source
	// script
	Calldata []byte `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
}

func (m *RawRequest) Reset()         { *m = RawRequest{} }
func (m *RawRequest) String() string { return proto.CompactTextString(m) }
func (*RawRequest) ProtoMessage()    {}
func (*RawRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{2}
}
func (m *RawRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRequest.Merge(m, src)
}
func (m *RawRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawRequest proto.InternalMessageInfo

func (m *RawRequest) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawRequest) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

func (m *RawRequest) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

// RawRequest is the data structure for storing raw reporter in the storage.
type RawReport struct {
	// ExternalID is an ID of the raw request
	ExternalID ExternalID `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	// ExitCode is status code provided by validators to specify error, if any.
	// Exit code is usually filled by the exit code returned from execution of
	// specified data source script. With code 0 means there is no error.
	ExitCode uint32 `protobuf:"varint,2,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// Data is raw result provided by validators.
	// It is usually filled by the result from execution of specified data source
	// script.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RawReport) Reset()         { *m = RawReport{} }
func (m *RawReport) String() string { return proto.CompactTextString(m) }
func (*RawReport) ProtoMessage()    {}
func (*RawReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{3}
}
func (m *RawReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawReport.Merge(m, src)
}
func (m *RawReport) XXX_Size() int {
	return m.Size()
}
func (m *RawReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RawReport.DiscardUnknown(m)
}

var xxx_messageInfo_RawReport proto.InternalMessageInfo

func (m *RawReport) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawReport) GetExitCode() uint32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *RawReport) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Request is the data structure for storing requests in the storage.
type Request struct {
	// OracleScriptID is ID of an oracle script
	OracleScriptID OracleScriptID `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the data used as argument params for the oracle script
	Calldata []byte `protobuf:"bytes,2,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// RequestedValidators is a list of validator addresses that are assigned for
	// fulfilling the request
	RequestedValidators []string `protobuf:"bytes,3,rep,name=requested_validators,json=requestedValidators,proto3" json:"requested_validators,omitempty"`
	// MinCount is minimum number of validators required for fulfilling the
	// request
	MinCount uint64 `protobuf:"varint,4,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// RequestHeight is block height that the request has been created
	RequestHeight int64 `protobuf:"varint,5,opt,name=request_height,json=requestHeight,proto3" json:"request_height,omitempty"`
	// RequestTime is timestamp of the chain's block which contains the request
	RequestTime int64 `protobuf:"varint,6,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ClientID is arbitrary id provided by requester.
	// It is used by client-side for referencing the request
	ClientID string `protobuf:"bytes,7,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// RawRequests is a list of raw requests specified by execution of oracle
	// script
	RawRequests []RawRequest `protobuf:"bytes,8,rep,name=raw_requests,json=rawRequests,proto3" json:"raw_requests"`
	// IBCChannel is an IBC channel info of the other chain, which contains a
	// channel and a port to allow odinchain connect to that chain. This field
	// allows other chain be able to request data from odinchain via IBC.
	IBCChannel *IBCChannel `protobuf:"bytes,9,opt,name=ibc_channel,json=ibcChannel,proto3" json:"ibc_channel,omitempty"`
	// ExecuteGas is amount of gas to reserve for executing
	ExecuteGas uint64 `protobuf:"varint,10,opt,name=execute_gas,json=executeGas,proto3" json:"execute_gas,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{4}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *Request) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *Request) GetRequestedValidators() []string {
	if m != nil {
		return m.RequestedValidators
	}
	return nil
}

func (m *Request) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *Request) GetRequestHeight() int64 {
	if m != nil {
		return m.RequestHeight
	}
	return 0
}

func (m *Request) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetRawRequests() []RawRequest {
	if m != nil {
		return m.RawRequests
	}
	return nil
}

func (m *Request) GetIBCChannel() *IBCChannel {
	if m != nil {
		return m.IBCChannel
	}
	return nil
}

func (m *Request) GetExecuteGas() uint64 {
	if m != nil {
		return m.ExecuteGas
	}
	return 0
}

// Report is the data structure for storing reports in the storage.
type Report struct {
	// Validator is a validator address who submit the report
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// InBeforeResolve indicates whether the report is submitted before the
	// request resolved
	InBeforeResolve bool `protobuf:"varint,2,opt,name=in_before_resolve,json=inBeforeResolve,proto3" json:"in_before_resolve,omitempty"`
	// RawReports is list of raw reports provided by the validator.
	// Each raw report has different external ID
	RawReports []RawReport `protobuf:"bytes,3,rep,name=raw_reports,json=rawReports,proto3" json:"raw_reports"`
}

func (m *Report) Reset()         { *m = Report{} }
func (m *Report) String() string { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()    {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{5}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Report.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *Report) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *Report) GetInBeforeResolve() bool {
	if m != nil {
		return m.InBeforeResolve
	}
	return false
}

func (m *Report) GetRawReports() []RawReport {
	if m != nil {
		return m.RawReports
	}
	return nil
}

// OracleRequestPacketData encodes an oracle request sent from other blockchains
// to OdinChain.
type OracleRequestPacketData struct {
	// ClientID is the unique identifier of this oracle request, as specified by
	// the client. This same unique ID will be sent back to the requester with the
	// oracle response.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// OracleScriptID is the unique identifier of the oracle script to be
	// executed.
	OracleScriptID OracleScriptID `protobuf:"varint,2,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the OBI-encoded calldata bytes available for oracle executor to
	// read.
	Calldata []byte `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators that are requested to respond to this
	// oracle request. Higher value means more security, at a higher gas cost.
	AskCount uint64 `protobuf:"varint,4,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators necessary for the request to
	// proceed to the execution phase. Higher value means more security, at the
	// cost of liveness.
	MinCount uint64 `protobuf:"varint,5,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// FeeLimit is the maximum tokens that will be paid to all data source
	// providers.
	FeeLimit github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=fee_limit,json=feeLimit,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee_limit"`
	// PrepareGas is amount of gas to pay to prepare raw requests
	PrepareGas uint64 `protobuf:"varint,7,opt,name=prepare_gas,json=prepareGas,proto3" json:"prepare_gas,omitempty"`
	// ExecuteGas is amount of gas to reserve for executing
	ExecuteGas uint64 `protobuf:"varint,8,opt,name=execute_gas,json=executeGas,proto3" json:"execute_gas,omitempty"`
}

func (m *OracleRequestPacketData) Reset()         { *m = OracleRequestPacketData{} }
func (m *OracleRequestPacketData) String() string { return proto.CompactTextString(m) }
func (*OracleRequestPacketData) ProtoMessage()    {}
func (*OracleRequestPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{6}
}
func (m *OracleRequestPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestPacketData.Merge(m, src)
}
func (m *OracleRequestPacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestPacketData proto.InternalMessageInfo

func (m *OracleRequestPacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleRequestPacketData) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *OracleRequestPacketData) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *OracleRequestPacketData) GetAskCount() uint64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *OracleRequestPacketData) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *OracleRequestPacketData) GetFeeLimit() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.FeeLimit
	}
	return nil
}

func (m *OracleRequestPacketData) GetPrepareGas() uint64 {
	if m != nil {
		return m.PrepareGas
	}
	return 0
}

func (m *OracleRequestPacketData) GetExecuteGas() uint64 {
	if m != nil {
		return m.ExecuteGas
	}
	return 0
}

// OracleRequestPacketAcknowledgement encodes an oracle request acknowledgement
// send back to requester chain.
type OracleRequestPacketAcknowledgement struct {
	// RequestID is OdinChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
}

func (m *OracleRequestPacketAcknowledgement) Reset()         { *m = OracleRequestPacketAcknowledgement{} }
func (m *OracleRequestPacketAcknowledgement) String() string { return proto.CompactTextString(m) }
func (*OracleRequestPacketAcknowledgement) ProtoMessage()    {}
func (*OracleRequestPacketAcknowledgement) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{7}
}
func (m *OracleRequestPacketAcknowledgement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestPacketAcknowledgement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestPacketAcknowledgement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestPacketAcknowledgement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestPacketAcknowledgement.Merge(m, src)
}
func (m *OracleRequestPacketAcknowledgement) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestPacketAcknowledgement) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestPacketAcknowledgement.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestPacketAcknowledgement proto.InternalMessageInfo

func (m *OracleRequestPacketAcknowledgement) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

// OracleResponsePacketData encodes an oracle response from OdinChain to the
// requester.
type OracleResponsePacketData struct {
	// ClientID is the unique identifier matched with that of the oracle request
	// packet.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// RequestID is OdinChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// AnsCount is the number of validators among to the asked validators that
	// actually responded to this oracle request prior to this oracle request
	// being resolved.
	AnsCount uint64 `protobuf:"varint,3,opt,name=ans_count,json=ansCount,proto3" json:"ans_count,omitempty"`
	// RequestTime is the UNIX epoch time at which the request was sent to
	// OdinChain.
	RequestTime int64 `protobuf:"varint,4,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ResolveTime is the UNIX epoch time at which the request was resolved to the
	// final result.
	ResolveTime int64 `protobuf:"varint,5,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// ResolveStatus is the status of this oracle request, which can be OK,
	// FAILURE, or EXPIRED.
	ResolveStatus ResolveStatus `protobuf:"varint,6,opt,name=resolve_status,json=resolveStatus,proto3,enum=oracle.v1.ResolveStatus" json:"resolve_status,omitempty"`
	// Result is the final aggregated value encoded in OBI format. Only available
	// if status if OK.
	Result []byte `protobuf:"bytes,7,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *OracleResponsePacketData) Reset()         { *m = OracleResponsePacketData{} }
func (m *OracleResponsePacketData) String() string { return proto.CompactTextString(m) }
func (*OracleResponsePacketData) ProtoMessage()    {}
func (*OracleResponsePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{8}
}
func (m *OracleResponsePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleResponsePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleResponsePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleResponsePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleResponsePacketData.Merge(m, src)
}
func (m *OracleResponsePacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleResponsePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleResponsePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleResponsePacketData proto.InternalMessageInfo

func (m *OracleResponsePacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleResponsePacketData) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *OracleResponsePacketData) GetAnsCount() uint64 {
	if m != nil {
		return m.AnsCount
	}
	return 0
}

func (m *OracleResponsePacketData) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveStatus() ResolveStatus {
	if m != nil {
		return m.ResolveStatus
	}
	return RESOLVE_STATUS_OPEN
}

func (m *OracleResponsePacketData) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

// Result encodes a result of request and store in chain
type Result struct {
	// ClientID is the unique identifier of this oracle request, as specified by
	// the client. This same unique ID will be sent back to the requester with the
	// oracle response.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// OracleScriptID is the unique identifier of the oracle script to be
	// executed.
	OracleScriptID OracleScriptID `protobuf:"varint,2,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the calldata bytes available for oracle executor to read.
	Calldata []byte `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators that are requested to respond to this
	// oracle request. Higher value means more security, at a higher gas cost.
	AskCount uint64 `protobuf:"varint,4,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators necessary for the request to
	// proceed to the execution phase. Higher value means more security, at the
	// cost of liveness.
	MinCount uint64 `protobuf:"varint,5,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// RequestID is OdinChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,6,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// AnsCount is the number of validators among to the asked validators that
	// actually responded to this oracle request prior to this oracle request
	// being resolved.
	AnsCount uint64 `protobuf:"varint,7,opt,name=ans_count,json=ansCount,proto3" json:"ans_count,omitempty"`
	// RequestTime is the UNIX epoch time at which the request was sent to
	// OdinChain.
	RequestTime int64 `protobuf:"varint,8,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ResolveTime is the UNIX epoch time at which the request was resolved to the
	// final result.
	ResolveTime int64 `protobuf:"varint,9,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// ResolveStatus is the status of this oracle request, which can be OK,
	// FAILURE, or EXPIRED.
	ResolveStatus ResolveStatus `protobuf:"varint,10,opt,name=resolve_status,json=resolveStatus,proto3,enum=oracle.v1.ResolveStatus" json:"resolve_status,omitempty"`
	// Result is the final aggregated value only available if status if OK.
	Result []byte `protobuf:"bytes,11,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{9}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Result) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *Result) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *Result) GetAskCount() uint64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *Result) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *Result) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Result) GetAnsCount() uint64 {
	if m != nil {
		return m.AnsCount
	}
	return 0
}

func (m *Result) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *Result) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

func (m *Result) GetResolveStatus() ResolveStatus {
	if m != nil {
		return m.ResolveStatus
	}
	return RESOLVE_STATUS_OPEN
}

func (m *Result) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

// ValidatorStatus maintains whether a validator is an active oracle provider.
type ValidatorStatus struct {
	// IsActive is a boolean indicating active status of validator.
	// The validator will be deactivated when they are unable to send reports
	// to fulfill oracle request before the request expired.
	IsActive bool `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// Since is a block timestamp when validator has been activated/deactivated
	Since time.Time `protobuf:"bytes,2,opt,name=since,proto3,stdtime" json:"since"`
}

func (m *ValidatorStatus) Reset()         { *m = ValidatorStatus{} }
func (m *ValidatorStatus) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatus) ProtoMessage()    {}
func (*ValidatorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{10}
}
func (m *ValidatorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatus.Merge(m, src)
}
func (m *ValidatorStatus) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatus proto.InternalMessageInfo

func (m *ValidatorStatus) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ValidatorStatus) GetSince() time.Time {
	if m != nil {
		return m.Since
	}
	return time.Time{}
}

// ActiveValidator is information of currently active validator
type ActiveValidator struct {
	// Address is a validator address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Power is an amount of token that the validator is holding
	Power uint64 `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *ActiveValidator) Reset()         { *m = ActiveValidator{} }
func (m *ActiveValidator) String() string { return proto.CompactTextString(m) }
func (*ActiveValidator) ProtoMessage()    {}
func (*ActiveValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{11}
}
func (m *ActiveValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveValidator.Merge(m, src)
}
func (m *ActiveValidator) XXX_Size() int {
	return m.Size()
}
func (m *ActiveValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveValidator.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveValidator proto.InternalMessageInfo

func (m *ActiveValidator) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ActiveValidator) GetPower() uint64 {
	if m != nil {
		return m.Power
	}
	return 0
}

// Params is the data structure that keeps the parameters of the oracle module.
type Params struct {
	// MaxRawRequestCount is the maximum number of data source raw requests a
	// request can make.
	MaxRawRequestCount uint64 `protobuf:"varint,1,opt,name=max_raw_request_count,json=maxRawRequestCount,proto3" json:"max_raw_request_count,omitempty"`
	// MaxAskCount is the maximum number of validators a request can target.
	MaxAskCount uint64 `protobuf:"varint,2,opt,name=max_ask_count,json=maxAskCount,proto3" json:"max_ask_count,omitempty"`
	// MaxCalldataSize is the maximum size limit of calldata (bytes) in a request.
	MaxCalldataSize uint64 `protobuf:"varint,3,opt,name=max_calldata_size,json=maxCalldataSize,proto3" json:"max_calldata_size,omitempty"`
	// MaxReportDataSize is the maximum size limit of report data (bytes) in a
	// report.
	MaxReportDataSize uint64 `protobuf:"varint,4,opt,name=max_report_data_size,json=maxReportDataSize,proto3" json:"max_report_data_size,omitempty"`
	// ExpirationBlockCount is the number of blocks a request stays valid before
	// it gets expired due to insufficient reports.
	ExpirationBlockCount uint64 `protobuf:"varint,5,opt,name=expiration_block_count,json=expirationBlockCount,proto3" json:"expiration_block_count,omitempty"`
	// BaseOwasmGas is the base amount of Cosmos-SDK gas charged for owasm
	// execution.
	BaseOwasmGas uint64 `protobuf:"varint,6,opt,name=base_owasm_gas,json=baseOwasmGas,proto3" json:"base_owasm_gas,omitempty"`
	// PerValidatorRequestGas is the amount of Cosmos-SDK gas charged per
	// requested validator.
	PerValidatorRequestGas uint64 `protobuf:"varint,7,opt,name=per_validator_request_gas,json=perValidatorRequestGas,proto3" json:"per_validator_request_gas,omitempty"`
	// SamplingTryCount the number of validator sampling tries to pick the highest
	// voting power subset of validators to perform an oracle task.
	SamplingTryCount uint64 `protobuf:"varint,8,opt,name=sampling_try_count,json=samplingTryCount,proto3" json:"sampling_try_count,omitempty"`
	// OracleRewardPercentage is the percentage of block rewards allocated to
	// active oracle validators.
	OracleRewardPercentage uint64 `protobuf:"varint,9,opt,name=oracle_reward_percentage,json=oracleRewardPercentage,proto3" json:"oracle_reward_percentage,omitempty"`
	// InactivePenaltyDuration is the duration period where a validator cannot
	// activate back after missing an oracle report.
	InactivePenaltyDuration uint64 `protobuf:"varint,10,opt,name=inactive_penalty_duration,json=inactivePenaltyDuration,proto3" json:"inactive_penalty_duration,omitempty"`
	// IBCRequestEnabled is a flag indicating whether sending oracle request via
	// IBC is allowed
	IBCRequestEnabled bool `protobuf:"varint,11,opt,name=ibc_request_enabled,json=ibcRequestEnabled,proto3" json:"ibc_request_enabled,omitempty"`
	// DataProviderRewardPerByte is the amount of tokens, user gets for the byte
	// of data provided
	DataProviderRewardPerByte github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,12,rep,name=data_provider_reward_per_byte,json=dataProviderRewardPerByte,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"data_provider_reward_per_byte"`
	// DataProviderRewardThreshold is the maximum amount of tokens that can be
	// paid for data per time
	DataProviderRewardThreshold RewardThreshold `protobuf:"bytes,13,opt,name=data_provider_reward_threshold,json=dataProviderRewardThreshold,proto3" json:"data_provider_reward_threshold"`
	// RewardDecreasingFraction is the percentage by which the cost of data per
	// byte is reduced when the limit is reached
	RewardDecreasingFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=reward_decreasing_fraction,json=rewardDecreasingFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reward_decreasing_fraction"`
	// Denominations that can be used for withdrawing fee from data requesters
	DataRequesterFeeDenoms []string `protobuf:"bytes,15,rep,name=data_requester_fee_denoms,json=dataRequesterFeeDenoms,proto3" json:"data_requester_fee_denoms,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{12}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxRawRequestCount() uint64 {
	if m != nil {
		return m.MaxRawRequestCount
	}
	return 0
}

func (m *Params) GetMaxAskCount() uint64 {
	if m != nil {
		return m.MaxAskCount
	}
	return 0
}

func (m *Params) GetMaxCalldataSize() uint64 {
	if m != nil {
		return m.MaxCalldataSize
	}
	return 0
}

func (m *Params) GetMaxReportDataSize() uint64 {
	if m != nil {
		return m.MaxReportDataSize
	}
	return 0
}

func (m *Params) GetExpirationBlockCount() uint64 {
	if m != nil {
		return m.ExpirationBlockCount
	}
	return 0
}

func (m *Params) GetBaseOwasmGas() uint64 {
	if m != nil {
		return m.BaseOwasmGas
	}
	return 0
}

func (m *Params) GetPerValidatorRequestGas() uint64 {
	if m != nil {
		return m.PerValidatorRequestGas
	}
	return 0
}

func (m *Params) GetSamplingTryCount() uint64 {
	if m != nil {
		return m.SamplingTryCount
	}
	return 0
}

func (m *Params) GetOracleRewardPercentage() uint64 {
	if m != nil {
		return m.OracleRewardPercentage
	}
	return 0
}

func (m *Params) GetInactivePenaltyDuration() uint64 {
	if m != nil {
		return m.InactivePenaltyDuration
	}
	return 0
}

func (m *Params) GetIBCRequestEnabled() bool {
	if m != nil {
		return m.IBCRequestEnabled
	}
	return false
}

func (m *Params) GetDataProviderRewardPerByte() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.DataProviderRewardPerByte
	}
	return nil
}

func (m *Params) GetDataProviderRewardThreshold() RewardThreshold {
	if m != nil {
		return m.DataProviderRewardThreshold
	}
	return RewardThreshold{}
}

func (m *Params) GetDataRequesterFeeDenoms() []string {
	if m != nil {
		return m.DataRequesterFeeDenoms
	}
	return nil
}

// PendingResolveList is a list of requests that are waiting to be resolved
type PendingResolveList struct {
	// RequestIDs is a list of request IDs that are waiting to be resolved
	RequestIds []uint64 `protobuf:"varint,1,rep,packed,name=request_ids,json=requestIds,proto3" json:"request_ids,omitempty"`
}

func (m *PendingResolveList) Reset()         { *m = PendingResolveList{} }
func (m *PendingResolveList) String() string { return proto.CompactTextString(m) }
func (*PendingResolveList) ProtoMessage()    {}
func (*PendingResolveList) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{13}
}
func (m *PendingResolveList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingResolveList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingResolveList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingResolveList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingResolveList.Merge(m, src)
}
func (m *PendingResolveList) XXX_Size() int {
	return m.Size()
}
func (m *PendingResolveList) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingResolveList.DiscardUnknown(m)
}

var xxx_messageInfo_PendingResolveList proto.InternalMessageInfo

func (m *PendingResolveList) GetRequestIds() []uint64 {
	if m != nil {
		return m.RequestIds
	}
	return nil
}

// IBCChannel is information of IBC protocol to allow communicating with other
// chain
type IBCChannel struct {
	// PortID is port ID used for sending response packet when request is
	// resolved.
	PortId string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// ChannelID is channel ID used for sending response packet when request is
	// resolved.
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
}

func (m *IBCChannel) Reset()         { *m = IBCChannel{} }
func (m *IBCChannel) String() string { return proto.CompactTextString(m) }
func (*IBCChannel) ProtoMessage()    {}
func (*IBCChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{14}
}
func (m *IBCChannel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IBCChannel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IBCChannel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IBCChannel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IBCChannel.Merge(m, src)
}
func (m *IBCChannel) XXX_Size() int {
	return m.Size()
}
func (m *IBCChannel) XXX_DiscardUnknown() {
	xxx_messageInfo_IBCChannel.DiscardUnknown(m)
}

var xxx_messageInfo_IBCChannel proto.InternalMessageInfo

func (m *IBCChannel) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *IBCChannel) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// RequestVerification is a message that is constructed and signed by a reporter
// to be used as a part of verification of oracle request.
type RequestVerification struct {
	// ChainID is the ID of targeted chain
	ChainID string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Validator is an validator address
	Validator string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	// RequestID is the targeted request ID
	RequestID RequestID `protobuf:"varint,3,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// ExternalID is the oracle's external ID of data source
	ExternalID ExternalID `protobuf:"varint,4,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	// DataSourceID is the ID of data source
	DataSourceID DataSourceID `protobuf:"varint,5,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
}

func (m *RequestVerification) Reset()         { *m = RequestVerification{} }
func (m *RequestVerification) String() string { return proto.CompactTextString(m) }
func (*RequestVerification) ProtoMessage()    {}
func (*RequestVerification) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{15}
}
func (m *RequestVerification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVerification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVerification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVerification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVerification.Merge(m, src)
}
func (m *RequestVerification) XXX_Size() int {
	return m.Size()
}
func (m *RequestVerification) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVerification.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVerification proto.InternalMessageInfo

func (m *RequestVerification) GetChainID() string {
	if m != nil {
		return m.ChainID
	}
	return ""
}

func (m *RequestVerification) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *RequestVerification) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *RequestVerification) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RequestVerification) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

// PriceResult is a result from standard price reference
type PriceResult struct {
	// Symbol is unit of data indicating what the data is. It is price currencies
	// for this case.
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Multiplier is a number used for left-shifting value to eliminate decimal
	// digits
	Multiplier uint64 `protobuf:"varint,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	// Px is the actual data, which is rate number multiplied by the multiplier.
	Px uint64 `protobuf:"varint,3,opt,name=px,proto3" json:"px,omitempty"`
	// RequestID is oracle request ID that contains this price
	RequestID RequestID `protobuf:"varint,4,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// ResolveTime is epoch timestamp indicating the time when the request had
	// been resolved
	ResolveTime int64 `protobuf:"varint,5,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
}

func (m *PriceResult) Reset()         { *m = PriceResult{} }
func (m *PriceResult) String() string { return proto.CompactTextString(m) }
func (*PriceResult) ProtoMessage()    {}
func (*PriceResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{16}
}
func (m *PriceResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceResult.Merge(m, src)
}
func (m *PriceResult) XXX_Size() int {
	return m.Size()
}
func (m *PriceResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceResult.DiscardUnknown(m)
}

var xxx_messageInfo_PriceResult proto.InternalMessageInfo

func (m *PriceResult) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *PriceResult) GetMultiplier() uint64 {
	if m != nil {
		return m.Multiplier
	}
	return 0
}

func (m *PriceResult) GetPx() uint64 {
	if m != nil {
		return m.Px
	}
	return 0
}

func (m *PriceResult) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *PriceResult) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

type OraclePool struct {
	DataProvidersPool github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=data_providers_pool,json=dataProvidersPool,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"data_providers_pool"`
}

func (m *OraclePool) Reset()         { *m = OraclePool{} }
func (m *OraclePool) String() string { return proto.CompactTextString(m) }
func (*OraclePool) ProtoMessage()    {}
func (*OraclePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{17}
}
func (m *OraclePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePool.Merge(m, src)
}
func (m *OraclePool) XXX_Size() int {
	return m.Size()
}
func (m *OraclePool) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePool.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePool proto.InternalMessageInfo

func (m *OraclePool) GetDataProvidersPool() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.DataProvidersPool
	}
	return nil
}

type DataProviderAccumulatedReward struct {
	DataProvider       string                                   `protobuf:"bytes,1,opt,name=data_provider,json=dataProvider,proto3" json:"data_provider,omitempty"`
	DataProviderReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=data_provider_reward,json=dataProviderReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"data_provider_reward"`
}

func (m *DataProviderAccumulatedReward) Reset()         { *m = DataProviderAccumulatedReward{} }
func (m *DataProviderAccumulatedReward) String() string { return proto.CompactTextString(m) }
func (*DataProviderAccumulatedReward) ProtoMessage()    {}
func (*DataProviderAccumulatedReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{18}
}
func (m *DataProviderAccumulatedReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProviderAccumulatedReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataProviderAccumulatedReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataProviderAccumulatedReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProviderAccumulatedReward.Merge(m, src)
}
func (m *DataProviderAccumulatedReward) XXX_Size() int {
	return m.Size()
}
func (m *DataProviderAccumulatedReward) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProviderAccumulatedReward.DiscardUnknown(m)
}

var xxx_messageInfo_DataProviderAccumulatedReward proto.InternalMessageInfo

func (m *DataProviderAccumulatedReward) GetDataProvider() string {
	if m != nil {
		return m.DataProvider
	}
	return ""
}

func (m *DataProviderAccumulatedReward) GetDataProviderReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.DataProviderReward
	}
	return nil
}

type DataProvidersAccumulatedRewards struct {
	CurrentRewardPerByte github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=current_reward_per_byte,json=currentRewardPerByte,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"current_reward_per_byte"`
	AccumulatedAmount    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=accumulated_amount,json=accumulatedAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"accumulated_amount"`
}

func (m *DataProvidersAccumulatedRewards) Reset()         { *m = DataProvidersAccumulatedRewards{} }
func (m *DataProvidersAccumulatedRewards) String() string { return proto.CompactTextString(m) }
func (*DataProvidersAccumulatedRewards) ProtoMessage()    {}
func (*DataProvidersAccumulatedRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{19}
}
func (m *DataProvidersAccumulatedRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProvidersAccumulatedRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataProvidersAccumulatedRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataProvidersAccumulatedRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProvidersAccumulatedRewards.Merge(m, src)
}
func (m *DataProvidersAccumulatedRewards) XXX_Size() int {
	return m.Size()
}
func (m *DataProvidersAccumulatedRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProvidersAccumulatedRewards.DiscardUnknown(m)
}

var xxx_messageInfo_DataProvidersAccumulatedRewards proto.InternalMessageInfo

func (m *DataProvidersAccumulatedRewards) GetCurrentRewardPerByte() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CurrentRewardPerByte
	}
	return nil
}

func (m *DataProvidersAccumulatedRewards) GetAccumulatedAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.AccumulatedAmount
	}
	return nil
}

type AccumulatedPaymentsForData struct {
	AccumulatedAmount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=accumulated_amount,json=accumulatedAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"accumulated_amount"`
}

func (m *AccumulatedPaymentsForData) Reset()         { *m = AccumulatedPaymentsForData{} }
func (m *AccumulatedPaymentsForData) String() string { return proto.CompactTextString(m) }
func (*AccumulatedPaymentsForData) ProtoMessage()    {}
func (*AccumulatedPaymentsForData) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{20}
}
func (m *AccumulatedPaymentsForData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccumulatedPaymentsForData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccumulatedPaymentsForData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccumulatedPaymentsForData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatedPaymentsForData.Merge(m, src)
}
func (m *AccumulatedPaymentsForData) XXX_Size() int {
	return m.Size()
}
func (m *AccumulatedPaymentsForData) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatedPaymentsForData.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatedPaymentsForData proto.InternalMessageInfo

func (m *AccumulatedPaymentsForData) GetAccumulatedAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.AccumulatedAmount
	}
	return nil
}

// RewardThreshold
type RewardThreshold struct {
	// Amount is the maximum amount of tokens that can be paid for data
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
	// Blocks is the number of blocks during which the sum of the reward should
	// not exceed total_reward_amount
	Blocks uint64 `protobuf:"varint,2,opt,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *RewardThreshold) Reset()         { *m = RewardThreshold{} }
func (m *RewardThreshold) String() string { return proto.CompactTextString(m) }
func (*RewardThreshold) ProtoMessage()    {}
func (*RewardThreshold) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{21}
}
func (m *RewardThreshold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardThreshold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardThreshold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardThreshold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardThreshold.Merge(m, src)
}
func (m *RewardThreshold) XXX_Size() int {
	return m.Size()
}
func (m *RewardThreshold) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardThreshold.DiscardUnknown(m)
}

var xxx_messageInfo_RewardThreshold proto.InternalMessageInfo

func (m *RewardThreshold) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *RewardThreshold) GetBlocks() uint64 {
	if m != nil {
		return m.Blocks
	}
	return 0
}

type RequestResult struct {
	Request *Request `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	Result  *Result  `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
	Reports []Report `protobuf:"bytes,3,rep,name=reports,proto3" json:"reports"`
}

func (m *RequestResult) Reset()         { *m = RequestResult{} }
func (m *RequestResult) String() string { return proto.CompactTextString(m) }
func (*RequestResult) ProtoMessage()    {}
func (*RequestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{22}
}
func (m *RequestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestResult.Merge(m, src)
}
func (m *RequestResult) XXX_Size() int {
	return m.Size()
}
func (m *RequestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestResult.DiscardUnknown(m)
}

var xxx_messageInfo_RequestResult proto.InternalMessageInfo

func (m *RequestResult) GetRequest() *Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *RequestResult) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RequestResult) GetReports() []Report {
	if m != nil {
		return m.Reports
	}
	return nil
}

func init() {
	proto.RegisterEnum("oracle.v1.ResolveStatus", ResolveStatus_name, ResolveStatus_value)
	proto.RegisterType((*DataSource)(nil), "oracle.v1.DataSource")
	proto.RegisterType((*OracleScript)(nil), "oracle.v1.OracleScript")
	proto.RegisterType((*RawRequest)(nil), "oracle.v1.RawRequest")
	proto.RegisterType((*RawReport)(nil), "oracle.v1.RawReport")
	proto.RegisterType((*Request)(nil), "oracle.v1.Request")
	proto.RegisterType((*Report)(nil), "oracle.v1.Report")
	proto.RegisterType((*OracleRequestPacketData)(nil), "oracle.v1.OracleRequestPacketData")
	proto.RegisterType((*OracleRequestPacketAcknowledgement)(nil), "oracle.v1.OracleRequestPacketAcknowledgement")
	proto.RegisterType((*OracleResponsePacketData)(nil), "oracle.v1.OracleResponsePacketData")
	proto.RegisterType((*Result)(nil), "oracle.v1.Result")
	proto.RegisterType((*ValidatorStatus)(nil), "oracle.v1.ValidatorStatus")
	proto.RegisterType((*ActiveValidator)(nil), "oracle.v1.ActiveValidator")
	proto.RegisterType((*Params)(nil), "oracle.v1.Params")
	proto.RegisterType((*PendingResolveList)(nil), "oracle.v1.PendingResolveList")
	proto.RegisterType((*IBCChannel)(nil), "oracle.v1.IBCChannel")
	proto.RegisterType((*RequestVerification)(nil), "oracle.v1.RequestVerification")
	proto.RegisterType((*PriceResult)(nil), "oracle.v1.PriceResult")
	proto.RegisterType((*OraclePool)(nil), "oracle.v1.OraclePool")
	proto.RegisterType((*DataProviderAccumulatedReward)(nil), "oracle.v1.DataProviderAccumulatedReward")
	proto.RegisterType((*DataProvidersAccumulatedRewards)(nil), "oracle.v1.DataProvidersAccumulatedRewards")
	proto.RegisterType((*AccumulatedPaymentsForData)(nil), "oracle.v1.AccumulatedPaymentsForData")
	proto.RegisterType((*RewardThreshold)(nil), "oracle.v1.RewardThreshold")
	proto.RegisterType((*RequestResult)(nil), "oracle.v1.RequestResult")
}

func init() { proto.RegisterFile("oracle/v1/oracle.proto", fileDescriptor_652b57db11528d07) }

var fileDescriptor_652b57db11528d07 = []byte{
	// 2126 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcb, 0x8f, 0x23, 0x47,
	0x19, 0x9f, 0xb6, 0x3d, 0x33, 0xf6, 0x67, 0xcf, 0xab, 0x76, 0x32, 0xeb, 0xf5, 0x66, 0xc7, 0xc3,
	0x10, 0xa2, 0xcd, 0x2a, 0x6b, 0x33, 0x0b, 0x42, 0xec, 0x86, 0x87, 0xc6, 0x8f, 0x09, 0x86, 0xd1,
	0x8e, 0xd5, 0x9e, 0x5d, 0x21, 0x24, 0xd4, 0x2a, 0x77, 0xd7, 0x78, 0x4a, 0xd3, 0x2f, 0xaa, 0xda,
	0xf3, 0x58, 0xc4, 0x01, 0x4e, 0x28, 0x12, 0x52, 0x24, 0x40, 0xe2, 0x40, 0x50, 0x50, 0x2e, 0x88,
	0x2b, 0xe2, 0x1f, 0xe0, 0x14, 0x4e, 0xe4, 0x84, 0x10, 0x07, 0x07, 0x79, 0x2f, 0xe1, 0x0f, 0xe0,
	0x02, 0x17, 0x54, 0x8f, 0xb6, 0xdb, 0x5e, 0x87, 0xcd, 0x6e, 0x66, 0x73, 0xe0, 0xe4, 0xfe, 0x1e,
	0x55, 0xf5, 0x3d, 0x7e, 0xdf, 0x57, 0x5f, 0x19, 0x36, 0x02, 0x86, 0x6d, 0x97, 0x54, 0x4f, 0x77,
	0xaa, 0xea, 0xab, 0x12, 0xb2, 0x20, 0x0a, 0x50, 0x4e, 0x53, 0xa7, 0x3b, 0xa5, 0xf5, 0x5e, 0xd0,
	0x0b, 0x24, 0xb7, 0x2a, 0xbe, 0x94, 0x42, 0xa9, 0xdc, 0x0b, 0x82, 0x9e, 0x4b, 0xaa, 0x92, 0xea,
	0xf6, 0x8f, 0xaa, 0x11, 0xf5, 0x08, 0x8f, 0xb0, 0x17, 0x6a, 0x85, 0x4d, 0x3b, 0xe0, 0x5e, 0xc0,
	0xab, 0x5d, 0xcc, 0xc5, 0xf6, 0x5d, 0x12, 0xe1, 0x9d, 0xaa, 0x1d, 0x50, 0x5f, 0xc9, 0xb7, 0xff,
	0x65, 0x00, 0x34, 0x70, 0x84, 0x3b, 0x41, 0x9f, 0xd9, 0x04, 0xad, 0xc3, 0x7c, 0x70, 0xe6, 0x13,
	0x56, 0x34, 0xb6, 0x8c, 0x9b, 0x39, 0x53, 0x11, 0x08, 0x41, 0xc6, 0xc7, 0x1e, 0x29, 0xa6, 0x24,
	0x53, 0x7e, 0xa3, 0x2d, 0xc8, 0x3b, 0x84, 0xdb, 0x8c, 0x86, 0x11, 0x0d, 0xfc, 0x62, 0x5a, 0x8a,
	0x92, 0x2c, 0x54, 0x82, 0xec, 0x11, 0x75, 0x89, 0x5c, 0x99, 0x91, 0xe2, 0x11, 0x2d, 0x64, 0x11,
	0x23, 0x98, 0xf7, 0xd9, 0x45, 0x71, 0x5e, 0xc9, 0x62, 0x1a, 0x7d, 0x1f, 0xd2, 0x47, 0x84, 0x14,
	0x17, 0xb6, 0xd2, 0x37, 0xf3, 0x77, 0xae, 0x55, 0x94, 0x03, 0x15, 0xe1, 0x40, 0x45, 0x3b, 0x50,
	0xa9, 0x07, 0xd4, 0xaf, 0x7d, 0xf1, 0xfd, 0x41, 0x79, 0xee, 0xf7, 0x1f, 0x96, 0x6f, 0xf6, 0x68,
	0x74, 0xdc, 0xef, 0x56, 0xec, 0xc0, 0xab, 0x6a, 0x6f, 0xd5, 0xcf, 0x6d, 0xee, 0x9c, 0x54, 0xa3,
	0x8b, 0x90, 0x70, 0xb9, 0x80, 0x9b, 0x62, 0xdf, 0x7b, 0x99, 0x8f, 0xde, 0x2d, 0x1b, 0xdb, 0x7f,
	0x31, 0xa0, 0x70, 0x20, 0x83, 0xdb, 0x91, 0x06, 0x7f, 0x66, 0x9e, 0x6f, 0xc0, 0x02, 0xb7, 0x8f,
	0x89, 0x87, 0xb5, 0xdf, 0x9a, 0x42, 0x77, 0x61, 0x85, 0xcb, 0x1c, 0x58, 0x76, 0xe0, 0x10, 0xab,
	0xcf, 0xdc, 0xe2, 0x82, 0x50, 0xa8, 0xad, 0x0d, 0x07, 0xe5, 0x25, 0x95, 0x9e, 0x7a, 0xe0, 0x90,
	0x07, 0xe6, 0xbe, 0xb9, 0xc4, 0xc7, 0x24, 0x73, 0xb5, 0x47, 0x7f, 0x34, 0x00, 0x4c, 0x7c, 0x66,
	0x92, 0x1f, 0xf4, 0x09, 0x8f, 0xd0, 0xd7, 0x21, 0x4f, 0xce, 0x23, 0xc2, 0x7c, 0xec, 0x5a, 0xd4,
	0x91, 0x5e, 0x65, 0x6a, 0x2f, 0x0f, 0x07, 0x65, 0x68, 0x6a, 0x76, 0xab, 0xf1, 0xef, 0x09, 0xca,
	0x84, 0x78, 0x41, 0xcb, 0x41, 0x7b, 0xb0, 0xec, 0xe0, 0x08, 0x5b, 0xda, 0x26, 0xea, 0xc8, 0x10,
	0x64, 0x6a, 0x5b, 0xc3, 0x41, 0xb9, 0x30, 0x06, 0x8c, 0xdc, 0x63, 0x82, 0x36, 0x0b, 0xce, 0x98,
	0x72, 0x44, 0x28, 0x6c, 0xec, 0xba, 0x82, 0x27, 0x23, 0x55, 0x30, 0x47, 0xb4, 0xb6, 0xfb, 0xc7,
	0x06, 0xe4, 0xa4, 0xdd, 0x61, 0xc0, 0x3e, 0xb5, 0xd9, 0xd7, 0x21, 0x47, 0xce, 0x69, 0x24, 0x63,
	0x28, 0x2d, 0x5e, 0x32, 0xb3, 0x82, 0x21, 0x42, 0x25, 0x92, 0x99, 0xb0, 0x23, 0x93, 0xb0, 0xe1,
	0x9f, 0x69, 0x58, 0x8c, 0x03, 0x77, 0x1f, 0x56, 0x55, 0xd5, 0x59, 0x2a, 0xa1, 0x63, 0x33, 0x5e,
	0x19, 0x0e, 0xca, 0xcb, 0x49, 0xd0, 0x48, 0x53, 0xa6, 0x38, 0xe6, 0x72, 0x90, 0xa4, 0x27, 0x23,
	0x90, 0x9a, 0x8c, 0x00, 0xda, 0x81, 0x75, 0xa6, 0x8e, 0x25, 0x8e, 0x75, 0x8a, 0x5d, 0xea, 0xe0,
	0x28, 0x60, 0xbc, 0x98, 0xde, 0x4a, 0xdf, 0xcc, 0x99, 0x57, 0x46, 0xb2, 0x87, 0x23, 0x91, 0xf0,
	0xd0, 0xa3, 0xbe, 0x65, 0x07, 0x7d, 0x3f, 0x92, 0xe0, 0xca, 0x98, 0x59, 0x8f, 0xfa, 0x75, 0x41,
	0xa3, 0x2f, 0xc0, 0xb2, 0x5e, 0x63, 0x1d, 0x13, 0xda, 0x3b, 0x8e, 0x24, 0xc8, 0xd2, 0xe6, 0x92,
	0xe6, 0x7e, 0x4b, 0x32, 0xd1, 0xe7, 0xa0, 0x10, 0xab, 0x89, 0x7e, 0x21, 0x81, 0x96, 0x36, 0xf3,
	0x9a, 0x77, 0x48, 0x3d, 0x82, 0x5e, 0x83, 0x9c, 0xed, 0x52, 0xe2, 0x4b, 0xf7, 0x17, 0x25, 0x10,
	0x0b, 0xc3, 0x41, 0x39, 0x5b, 0x97, 0xcc, 0x56, 0xc3, 0xcc, 0x2a, 0x71, 0xcb, 0x41, 0xdf, 0x80,
	0x02, 0xc3, 0x67, 0x96, 0x5e, 0xcd, 0x8b, 0x59, 0x59, 0xb8, 0x2f, 0x55, 0x46, 0xbd, 0xab, 0x32,
	0x86, 0x65, 0x2d, 0x23, 0x8a, 0xd6, 0xcc, 0xb3, 0x11, 0x87, 0xa3, 0x3d, 0xc8, 0xd3, 0xae, 0x6d,
	0xd9, 0xc7, 0xd8, 0xf7, 0x89, 0x5b, 0xcc, 0x6d, 0x19, 0x53, 0xcb, 0x5b, 0xb5, 0x7a, 0x5d, 0x09,
	0x6b, 0xcb, 0x02, 0x09, 0x63, 0xda, 0x04, 0xda, 0xb5, 0xf5, 0x37, 0x2a, 0x0b, 0xe8, 0x10, 0xbb,
	0x1f, 0x11, 0xab, 0x87, 0x79, 0x11, 0x64, 0x6c, 0x40, 0xb3, 0xde, 0xc4, 0x5c, 0xe7, 0xfa, 0x97,
	0x06, 0x2c, 0x68, 0xb0, 0xbd, 0x0c, 0xb9, 0x51, 0xd0, 0x75, 0xdd, 0x8f, 0x19, 0xe8, 0x16, 0xac,
	0x51, 0xdf, 0xea, 0x92, 0xa3, 0x80, 0x11, 0x8b, 0x11, 0x1e, 0xb8, 0xa7, 0x0a, 0x53, 0x59, 0x73,
	0x85, 0xfa, 0x35, 0xc9, 0x37, 0x15, 0x1b, 0xbd, 0x01, 0x79, 0x15, 0x03, 0xb1, 0xaf, 0xca, 0x5f,
	0xfe, 0xce, 0xfa, 0x74, 0x08, 0x84, 0x50, 0x47, 0x00, 0x58, 0xcc, 0x88, 0xed, 0xfa, 0x75, 0x1a,
	0xae, 0x2a, 0x28, 0xe9, 0xc8, 0xb4, 0xb1, 0x7d, 0x42, 0x22, 0x51, 0x5b, 0x93, 0xd9, 0x30, 0xfe,
	0x67, 0x36, 0x66, 0xc1, 0x37, 0x75, 0x49, 0xf0, 0x9d, 0x2a, 0x60, 0x81, 0x45, 0xcc, 0x4f, 0x26,
	0xb1, 0x88, 0xf9, 0x89, 0xc2, 0xe2, 0x04, 0x50, 0xe7, 0xa7, 0x80, 0x7a, 0x0c, 0xb9, 0x23, 0x42,
	0x2c, 0x97, 0x7a, 0x34, 0x7a, 0x11, 0x9d, 0x3e, 0x7b, 0x44, 0xc8, 0xbe, 0xd8, 0x5c, 0xa0, 0x22,
	0x64, 0x24, 0xc4, 0x4c, 0xa1, 0x62, 0x51, 0xa1, 0x42, 0xb3, 0xde, 0xc4, 0x7c, 0x1a, 0x36, 0xd9,
	0x8f, 0x81, 0x0d, 0x81, 0xed, 0x19, 0xd9, 0xd9, 0xb5, 0x4f, 0xfc, 0xe0, 0xcc, 0x25, 0x4e, 0x8f,
	0x78, 0xc4, 0x8f, 0xd0, 0x5d, 0x80, 0xb8, 0xb2, 0x46, 0x6d, 0xa3, 0x34, 0x1c, 0x94, 0x73, 0x7a,
	0x95, 0x0c, 0xf9, 0x98, 0x30, 0x73, 0x5a, 0xbb, 0xe5, 0xe8, 0x63, 0xfe, 0x94, 0x82, 0x62, 0x7c,
	0x0e, 0x0f, 0x03, 0x9f, 0x93, 0xe7, 0x83, 0xc1, 0xa4, 0x21, 0xa9, 0x67, 0x30, 0x44, 0x66, 0xd5,
	0xe7, 0x3a, 0x71, 0x69, 0x9d, 0x55, 0x9f, 0xab, 0xc4, 0x4d, 0xb7, 0x8e, 0xcc, 0x93, 0xad, 0x43,
	0xaa, 0xc8, 0xb2, 0x50, 0x2a, 0xf3, 0xb1, 0x8a, 0xe4, 0x49, 0x95, 0x6f, 0x8a, 0x3e, 0xa5, 0x54,
	0x78, 0x84, 0xa3, 0x3e, 0x97, 0x2d, 0x68, 0xf9, 0x4e, 0x31, 0x59, 0x31, 0x4a, 0xa1, 0x23, 0xe5,
	0xa2, 0x83, 0x25, 0x48, 0x71, 0x8b, 0x32, 0xc2, 0xfb, 0x6e, 0x24, 0x13, 0x5a, 0x30, 0x35, 0xa5,
	0x83, 0xf8, 0xd7, 0xb4, 0x28, 0x71, 0xc1, 0xf8, 0xff, 0xab, 0x9c, 0xc9, 0xc4, 0x2e, 0x3c, 0x77,
	0x62, 0x17, 0x9f, 0x92, 0xd8, 0xec, 0xd3, 0x13, 0x9b, 0xfb, 0x24, 0x89, 0x85, 0xe7, 0x4d, 0x6c,
	0x7e, 0x46, 0x62, 0x43, 0x58, 0x19, 0x5d, 0x85, 0x7a, 0xc1, 0x75, 0xc8, 0x51, 0x6e, 0x61, 0x3b,
	0xa2, 0xa7, 0x44, 0x26, 0x38, 0x6b, 0x66, 0x29, 0xdf, 0x95, 0x34, 0xba, 0x07, 0xf3, 0x9c, 0xfa,
	0xb6, 0x6a, 0xdb, 0xf9, 0x3b, 0xa5, 0x8a, 0x1a, 0x97, 0x2b, 0xf1, 0xb8, 0x5c, 0x39, 0x8c, 0xc7,
	0xe5, 0x5a, 0x56, 0xf4, 0x98, 0xb7, 0x3f, 0x2c, 0x1b, 0xa6, 0x5a, 0xa2, 0x4f, 0xdc, 0x85, 0x15,
	0xb5, 0xd7, 0xe8, 0x5c, 0x54, 0x84, 0x45, 0xec, 0x38, 0x8c, 0x70, 0xae, 0xef, 0x8c, 0x98, 0x14,
	0x33, 0x64, 0x18, 0x9c, 0x11, 0xa6, 0x60, 0x63, 0x2a, 0x62, 0xfb, 0xa3, 0x45, 0x58, 0x68, 0x63,
	0x86, 0x3d, 0x8e, 0x76, 0xe0, 0x25, 0x0f, 0x9f, 0x5b, 0x89, 0xeb, 0x52, 0x67, 0x43, 0x76, 0x0a,
	0x13, 0x79, 0xf8, 0x7c, 0x7c, 0x57, 0xaa, 0xbc, 0x6c, 0xc3, 0x92, 0x58, 0x32, 0x46, 0x8b, 0xda,
	0x3b, 0xef, 0xe1, 0xf3, 0xdd, 0x18, 0x30, 0xb7, 0x60, 0x4d, 0xe8, 0xc4, 0xe8, 0xb2, 0x38, 0x7d,
	0x44, 0x74, 0xe5, 0xae, 0x78, 0xf8, 0xbc, 0xae, 0xf9, 0x1d, 0xfa, 0x88, 0xa0, 0x2a, 0xac, 0x4b,
	0x13, 0xe4, 0xdd, 0x63, 0x8d, 0xd5, 0x15, 0x08, 0xc5, 0x3e, 0xea, 0x5a, 0x6a, 0xc4, 0x0b, 0xbe,
	0x0c, 0x1b, 0xe4, 0x3c, 0xa4, 0x0c, 0x8b, 0xd1, 0xd6, 0xea, 0xba, 0x81, 0x7d, 0x32, 0x01, 0xcd,
	0xf5, 0xb1, 0xb4, 0x26, 0x84, 0xca, 0xa4, 0x57, 0x60, 0x59, 0xf4, 0x71, 0x2b, 0x38, 0xc3, 0xdc,
	0x93, 0x8d, 0x55, 0x42, 0xd5, 0x2c, 0x08, 0xee, 0x81, 0x60, 0x8a, 0xde, 0x7b, 0x17, 0xae, 0x85,
	0x84, 0x8d, 0x27, 0x9f, 0x51, 0x54, 0xc6, 0xad, 0x7a, 0x23, 0x24, 0x6c, 0x14, 0x7b, 0x1d, 0x19,
	0xb1, 0xf4, 0x75, 0x40, 0x1c, 0x7b, 0xa1, 0x4b, 0xfd, 0x9e, 0x15, 0xb1, 0x0b, 0x6d, 0x92, 0xea,
	0xde, 0xab, 0xb1, 0xe4, 0x90, 0x5d, 0x28, 0x73, 0xbe, 0x0a, 0x45, 0x5d, 0xdb, 0x8c, 0x9c, 0x61,
	0xe6, 0x58, 0x21, 0x61, 0x36, 0xf1, 0x23, 0xdc, 0x53, 0x30, 0xce, 0x98, 0xfa, 0x09, 0x66, 0x4a,
	0x71, 0x7b, 0x24, 0x45, 0xf7, 0xe0, 0x1a, 0xf5, 0x15, 0xbc, 0xac, 0x90, 0xf8, 0xd8, 0x8d, 0x2e,
	0x2c, 0xa7, 0xaf, 0xfc, 0xd5, 0x33, 0xc6, 0xd5, 0x58, 0xa1, 0xad, 0xe4, 0x0d, 0x2d, 0x46, 0x4d,
	0xb8, 0x22, 0x26, 0x9b, 0xd8, 0x29, 0xe2, 0xe3, 0xae, 0x4b, 0x1c, 0x89, 0xec, 0x6c, 0xed, 0xa5,
	0xe1, 0xa0, 0xbc, 0xd6, 0xaa, 0xd5, 0xb5, 0x4f, 0x4d, 0x25, 0x34, 0xd7, 0x68, 0xd7, 0x9e, 0x64,
	0xa1, 0x9f, 0x19, 0x70, 0x43, 0x26, 0x2a, 0x64, 0xc1, 0x29, 0x75, 0x08, 0x4b, 0x38, 0x61, 0x75,
	0x2f, 0x22, 0x52, 0x2c, 0x5c, 0xfe, 0x0d, 0x7a, 0x4d, 0x9c, 0xd8, 0xd6, 0x07, 0x8e, 0xa2, 0x52,
	0xbb, 0x88, 0x08, 0x22, 0xb0, 0x39, 0xd3, 0x9c, 0xe8, 0x98, 0x11, 0x7e, 0x1c, 0xb8, 0x4e, 0x71,
	0x49, 0x97, 0x5b, 0xb2, 0xe8, 0x85, 0xca, 0x61, 0xac, 0xa1, 0xa7, 0xa0, 0xeb, 0x4f, 0x1e, 0x32,
	0x52, 0x41, 0x2e, 0x94, 0xf4, 0xc6, 0x0e, 0xb1, 0xc5, 0xe3, 0x50, 0xa4, 0xfa, 0x88, 0x89, 0x50,
	0x07, 0x7e, 0x71, 0x59, 0xb4, 0x87, 0x5a, 0x45, 0x6c, 0xf3, 0xf7, 0x41, 0xf9, 0xd5, 0x4f, 0xe0,
	0x57, 0x83, 0xd8, 0x66, 0x51, 0xed, 0xd8, 0x18, 0x6d, 0xb8, 0xa7, 0xf7, 0x13, 0x50, 0x94, 0x4e,
	0xc5, 0x33, 0x37, 0xb3, 0xc4, 0x80, 0xe2, 0x10, 0x3f, 0xf0, 0x78, 0x71, 0x45, 0xce, 0xe3, 0x1b,
	0x42, 0xc1, 0x8c, 0xe5, 0x7b, 0x84, 0x34, 0xa4, 0xf4, 0x5e, 0xf6, 0x57, 0xef, 0x96, 0xe7, 0x64,
	0xb7, 0x78, 0x03, 0x50, 0x9b, 0xf8, 0x0e, 0xf5, 0x7b, 0xba, 0xc9, 0xed, 0x53, 0x2e, 0x47, 0x90,
	0x71, 0xcb, 0x16, 0x4d, 0x23, 0x2d, 0x26, 0x8c, 0x51, 0x5f, 0x8e, 0x27, 0x8c, 0x6f, 0x43, 0x62,
	0xb2, 0x45, 0x57, 0x61, 0x51, 0x56, 0x68, 0x7c, 0x6d, 0x99, 0x0b, 0x82, 0x6c, 0x39, 0xe8, 0x06,
	0x80, 0x1e, 0x95, 0xe3, 0x0b, 0x2a, 0x67, 0xe6, 0x34, 0x67, 0x34, 0x46, 0xbc, 0x97, 0x82, 0x2b,
	0xda, 0xd2, 0x87, 0x84, 0xd1, 0x23, 0x6a, 0x2b, 0x44, 0xbe, 0x0a, 0x59, 0xfb, 0x18, 0x53, 0x7f,
	0x7c, 0x1b, 0xe6, 0x87, 0x83, 0xf2, 0x62, 0x5d, 0xf0, 0x5a, 0x0d, 0x73, 0x51, 0x0a, 0x5b, 0xce,
	0xe4, 0x64, 0x9c, 0x9a, 0x9e, 0x8c, 0x27, 0xef, 0xa0, 0xf4, 0xb3, 0xdc, 0x41, 0x53, 0xef, 0xbb,
	0xcc, 0xa7, 0x7e, 0x96, 0xce, 0x3f, 0xcf, 0xb3, 0x54, 0x47, 0xe9, 0x0f, 0x06, 0xe4, 0xdb, 0x8c,
	0xda, 0x44, 0x0f, 0x0b, 0xe2, 0x6d, 0x7e, 0xe1, 0x75, 0x03, 0x37, 0x0e, 0xb9, 0xa2, 0xd0, 0x26,
	0x80, 0xd7, 0x77, 0x23, 0x1a, 0xba, 0x74, 0xd4, 0xdc, 0x13, 0x1c, 0xb4, 0x0c, 0xa9, 0xf0, 0x5c,
	0x37, 0xdc, 0x54, 0x78, 0x3e, 0x15, 0x9f, 0xcc, 0xb3, 0xc4, 0xe7, 0xe9, 0xc3, 0xd3, 0xf6, 0xcf,
	0x0d, 0x00, 0x35, 0x7a, 0xb4, 0x83, 0xc0, 0x45, 0x3f, 0x84, 0x2b, 0x13, 0xd5, 0xc8, 0xad, 0x30,
	0x90, 0x1e, 0x5c, 0x7a, 0x4b, 0x58, 0x4b, 0x56, 0x2b, 0x17, 0x87, 0x4b, 0xe8, 0x1b, 0x32, 0x96,
	0x7f, 0x36, 0xe0, 0x46, 0x23, 0x21, 0xdf, 0xb5, 0xed, 0xbe, 0xd7, 0x77, 0x71, 0x44, 0x1c, 0x55,
	0xd8, 0xe8, 0xf3, 0xb0, 0x34, 0x61, 0xa8, 0x0e, 0x72, 0x21, 0xb9, 0x2b, 0xfa, 0x11, 0xac, 0xcf,
	0xea, 0x2d, 0xc5, 0xd4, 0xe5, 0xbb, 0x83, 0x9e, 0x6c, 0x3e, 0x12, 0x17, 0x73, 0xdb, 0xbf, 0x4b,
	0x41, 0x39, 0xe9, 0x0b, 0x7f, 0xc2, 0x19, 0x8e, 0x7e, 0x62, 0xc0, 0x55, 0xbb, 0xcf, 0x98, 0x18,
	0x2d, 0xa7, 0xdb, 0xf1, 0x0b, 0x88, 0xfd, 0xba, 0x3e, 0x6b, 0xb2, 0x13, 0x3f, 0x02, 0x84, 0xc7,
	0xa6, 0x59, 0xd8, 0xd3, 0x13, 0xc2, 0xe5, 0xa7, 0x3e, 0x71, 0xcc, 0xae, 0x3c, 0x45, 0x87, 0xea,
	0x37, 0x06, 0x94, 0x12, 0xd1, 0x69, 0xe3, 0x0b, 0xf1, 0x0e, 0xe2, 0x7b, 0x01, 0x93, 0x2f, 0x96,
	0xd9, 0x06, 0x1a, 0x9f, 0xa1, 0x81, 0xbf, 0x30, 0x60, 0x65, 0xfa, 0x66, 0xb1, 0x61, 0xe1, 0xc5,
	0x59, 0xa2, 0xb7, 0x16, 0xcd, 0x44, 0x0e, 0x4b, 0x5c, 0x37, 0x0c, 0x4d, 0xe9, 0xd6, 0xf3, 0x5b,
	0x03, 0x96, 0x74, 0x03, 0xd0, 0xcd, 0xe7, 0x75, 0x58, 0xd4, 0x6d, 0x40, 0x16, 0x46, 0xfe, 0x0e,
	0x9a, 0xb8, 0x3e, 0x95, 0x6a, 0xac, 0x82, 0x5e, 0x1b, 0xcd, 0xc9, 0x6a, 0xb4, 0x5d, 0x9b, 0x1c,
	0xb0, 0xfb, 0x6e, 0x14, 0x8f, 0xce, 0x68, 0x47, 0x6c, 0x9c, 0xfc, 0x5f, 0x62, 0x52, 0x37, 0xf1,
	0xa7, 0x44, 0xac, 0xa7, 0x6c, 0xbc, 0xf5, 0x1f, 0x69, 0x63, 0x72, 0x3a, 0xff, 0x1a, 0x94, 0xcd,
	0x66, 0xe7, 0x60, 0xff, 0x61, 0xd3, 0xea, 0x1c, 0xee, 0x1e, 0x3e, 0xe8, 0x58, 0x07, 0xed, 0xe6,
	0x7d, 0xeb, 0xc1, 0xfd, 0x4e, 0xbb, 0x59, 0x6f, 0xed, 0xb5, 0x9a, 0x8d, 0xd5, 0xb9, 0xd2, 0xd5,
	0xb7, 0xde, 0xd9, 0xba, 0x32, 0x43, 0x0d, 0x7d, 0x05, 0x36, 0xa6, 0xd8, 0x9d, 0x07, 0xf5, 0x7a,
	0xb3, 0xd3, 0x59, 0x35, 0x4a, 0xa5, 0xb7, 0xde, 0xd9, 0xfa, 0x18, 0xe9, 0x8c, 0x75, 0x7b, 0xbb,
	0xad, 0xfd, 0x07, 0x66, 0x73, 0x35, 0x35, 0x73, 0x9d, 0x96, 0xce, 0x58, 0xd7, 0xfc, 0x6e, 0xbb,
	0x65, 0x36, 0x1b, 0xab, 0xe9, 0x99, 0xeb, 0xb4, 0xb4, 0x94, 0xf9, 0xe9, 0x7b, 0x9b, 0x73, 0xb5,
	0xef, 0xbc, 0x3f, 0xdc, 0x34, 0x3e, 0x18, 0x6e, 0x1a, 0xff, 0x18, 0x6e, 0x1a, 0x6f, 0x3f, 0xde,
	0x9c, 0xfb, 0xe0, 0xf1, 0xe6, 0xdc, 0xdf, 0x1e, 0x6f, 0xce, 0x7d, 0x6f, 0x27, 0x81, 0x85, 0x83,
	0x46, 0xeb, 0xfe, 0xed, 0xb6, 0x79, 0x70, 0x78, 0x50, 0x3f, 0xd8, 0xaf, 0x06, 0x0e, 0xf5, 0x6f,
	0xdb, 0x01, 0x23, 0xd5, 0x73, 0xfd, 0x47, 0xbe, 0x82, 0x46, 0x77, 0x41, 0xbe, 0x38, 0xbe, 0xf4,
	0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x96, 0x9b, 0x0d, 0x4a, 0xe9, 0x17, 0x00, 0x00,
}

func (this *DataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSource)
	if !ok {
		that2, ok := that.(DataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.Treasury != that1.Treasury {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	return true
}
func (this *OracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleScript)
	if !ok {
		that2, ok := that.(OracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	return true
}
func (this *RawRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawRequest)
	if !ok {
		that2, ok := that.(RawRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	return true
}
func (this *RawReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawReport)
	if !ok {
		that2, ok := that.(RawReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.ExitCode != that1.ExitCode {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if len(this.RequestedValidators) != len(that1.RequestedValidators) {
		return false
	}
	for i := range this.RequestedValidators {
		if this.RequestedValidators[i] != that1.RequestedValidators[i] {
			return false
		}
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if this.RequestHeight != that1.RequestHeight {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if len(this.RawRequests) != len(that1.RawRequests) {
		return false
	}
	for i := range this.RawRequests {
		if !this.RawRequests[i].Equal(&that1.RawRequests[i]) {
			return false
		}
	}
	if !this.IBCChannel.Equal(that1.IBCChannel) {
		return false
	}
	if this.ExecuteGas != that1.ExecuteGas {
		return false
	}
	return true
}
func (this *Report) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Report)
	if !ok {
		that2, ok := that.(Report)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.InBeforeResolve != that1.InBeforeResolve {
		return false
	}
	if len(this.RawReports) != len(that1.RawReports) {
		return false
	}
	for i := range this.RawReports {
		if !this.RawReports[i].Equal(&that1.RawReports[i]) {
			return false
		}
	}
	return true
}
func (this *OracleRequestPacketData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleRequestPacketData)
	if !ok {
		that2, ok := that.(OracleRequestPacketData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.AskCount != that1.AskCount {
		return false
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if len(this.FeeLimit) != len(that1.FeeLimit) {
		return false
	}
	for i := range this.FeeLimit {
		if !this.FeeLimit[i].Equal(&that1.FeeLimit[i]) {
			return false
		}
	}
	if this.PrepareGas != that1.PrepareGas {
		return false
	}
	if this.ExecuteGas != that1.ExecuteGas {
		return false
	}
	return true
}
func (this *OracleRequestPacketAcknowledgement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleRequestPacketAcknowledgement)
	if !ok {
		that2, ok := that.(OracleRequestPacketAcknowledgement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	return true
}
func (this *OracleResponsePacketData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleResponsePacketData)
	if !ok {
		that2, ok := that.(OracleResponsePacketData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AnsCount != that1.AnsCount {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ResolveTime != that1.ResolveTime {
		return false
	}
	if this.ResolveStatus != that1.ResolveStatus {
		return false
	}
	if !bytes.Equal(this.Result, that1.Result) {
		return false
	}
	return true
}
func (this *Result) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Result)
	if !ok {
		that2, ok := that.(Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.AskCount != that1.AskCount {
		return false
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AnsCount != that1.AnsCount {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ResolveTime != that1.ResolveTime {
		return false
	}
	if this.ResolveStatus != that1.ResolveStatus {
		return false
	}
	if !bytes.Equal(this.Result, that1.Result) {
		return false
	}
	return true
}
func (this *ValidatorStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorStatus)
	if !ok {
		that2, ok := that.(ValidatorStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if !this.Since.Equal(that1.Since) {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxRawRequestCount != that1.MaxRawRequestCount {
		return false
	}
	if this.MaxAskCount != that1.MaxAskCount {
		return false
	}
	if this.MaxCalldataSize != that1.MaxCalldataSize {
		return false
	}
	if this.MaxReportDataSize != that1.MaxReportDataSize {
		return false
	}
	if this.ExpirationBlockCount != that1.ExpirationBlockCount {
		return false
	}
	if this.BaseOwasmGas != that1.BaseOwasmGas {
		return false
	}
	if this.PerValidatorRequestGas != that1.PerValidatorRequestGas {
		return false
	}
	if this.SamplingTryCount != that1.SamplingTryCount {
		return false
	}
	if this.OracleRewardPercentage != that1.OracleRewardPercentage {
		return false
	}
	if this.InactivePenaltyDuration != that1.InactivePenaltyDuration {
		return false
	}
	if this.IBCRequestEnabled != that1.IBCRequestEnabled {
		return false
	}
	if len(this.DataProviderRewardPerByte) != len(that1.DataProviderRewardPerByte) {
		return false
	}
	for i := range this.DataProviderRewardPerByte {
		if !this.DataProviderRewardPerByte[i].Equal(&that1.DataProviderRewardPerByte[i]) {
			return false
		}
	}
	if !this.DataProviderRewardThreshold.Equal(&that1.DataProviderRewardThreshold) {
		return false
	}
	if !this.RewardDecreasingFraction.Equal(that1.RewardDecreasingFraction) {
		return false
	}
	if len(this.DataRequesterFeeDenoms) != len(that1.DataRequesterFeeDenoms) {
		return false
	}
	for i := range this.DataRequesterFeeDenoms {
		if this.DataRequesterFeeDenoms[i] != that1.DataRequesterFeeDenoms[i] {
			return false
		}
	}
	return true
}
func (this *PendingResolveList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingResolveList)
	if !ok {
		that2, ok := that.(PendingResolveList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RequestIds) != len(that1.RequestIds) {
		return false
	}
	for i := range this.RequestIds {
		if this.RequestIds[i] != that1.RequestIds[i] {
			return false
		}
	}
	return true
}
func (this *IBCChannel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IBCChannel)
	if !ok {
		that2, ok := that.(IBCChannel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PortId != that1.PortId {
		return false
	}
	if this.ChannelId != that1.ChannelId {
		return false
	}
	return true
}
func (this *RequestVerification) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestVerification)
	if !ok {
		that2, ok := that.(RequestVerification)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainID != that1.ChainID {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	return true
}
func (this *OraclePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OraclePool)
	if !ok {
		that2, ok := that.(OraclePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DataProvidersPool) != len(that1.DataProvidersPool) {
		return false
	}
	for i := range this.DataProvidersPool {
		if !this.DataProvidersPool[i].Equal(&that1.DataProvidersPool[i]) {
			return false
		}
	}
	return true
}
func (this *RewardThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardThreshold)
	if !ok {
		that2, ok := that.(RewardThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Amount) != len(that1.Amount) {
		return false
	}
	for i := range this.Amount {
		if !this.Amount[i].Equal(&that1.Amount[i]) {
			return false
		}
	}
	if this.Blocks != that1.Blocks {
		return false
	}
	return true
}
func (this *RequestResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestResult)
	if !ok {
		that2, ok := that.(RequestResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Request.Equal(that1.Request) {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if len(this.Reports) != len(that1.Reports) {
		return false
	}
	for i := range this.Reports {
		if !this.Reports[i].Equal(&that1.Reports[i]) {
			return false
		}
	}
	return true
}
func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Treasury) > 0 {
		i -= len(m.Treasury)
		copy(dAtA[i:], m.Treasury)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Treasury)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataSourceID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExitCode != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecuteGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExecuteGas))
		i--
		dAtA[i] = 0x50
	}
	if m.IBCChannel != nil {
		{
			size, err := m.IBCChannel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RawRequests) > 0 {
		for iNdEx := len(m.RawRequests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRequests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RequestTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x30
	}
	if m.RequestHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.MinCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RequestedValidators) > 0 {
		for iNdEx := len(m.RequestedValidators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedValidators[iNdEx])
			copy(dAtA[i:], m.RequestedValidators[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.RequestedValidators[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawReports) > 0 {
		for iNdEx := len(m.RawReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InBeforeResolve {
		i--
		if m.InBeforeResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleRequestPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecuteGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExecuteGas))
		i--
		dAtA[i] = 0x40
	}
	if m.PrepareGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PrepareGas))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FeeLimit) > 0 {
		for iNdEx := len(m.FeeLimit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeLimit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MinCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AskCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleRequestPacketAcknowledgement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestPacketAcknowledgement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestPacketAcknowledgement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleResponsePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleResponsePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleResponsePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ResolveStatus != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.ResolveTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x20
	}
	if m.AnsCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AnsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ResolveStatus != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveStatus))
		i--
		dAtA[i] = 0x50
	}
	if m.ResolveTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x48
	}
	if m.RequestTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x40
	}
	if m.AnsCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AnsCount))
		i--
		dAtA[i] = 0x38
	}
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x30
	}
	if m.MinCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AskCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Since, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Since):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintOracle(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActiveValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Power != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataRequesterFeeDenoms) > 0 {
		for iNdEx := len(m.DataRequesterFeeDenoms) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DataRequesterFeeDenoms[iNdEx])
			copy(dAtA[i:], m.DataRequesterFeeDenoms[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.DataRequesterFeeDenoms[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	{
		size := m.RewardDecreasingFraction.Size()
		i -= size
		if _, err := m.RewardDecreasingFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size, err := m.DataProviderRewardThreshold.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.DataProviderRewardPerByte) > 0 {
		for iNdEx := len(m.DataProviderRewardPerByte) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataProviderRewardPerByte[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.IBCRequestEnabled {
		i--
		if m.IBCRequestEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.InactivePenaltyDuration != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.InactivePenaltyDuration))
		i--
		dAtA[i] = 0x50
	}
	if m.OracleRewardPercentage != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleRewardPercentage))
		i--
		dAtA[i] = 0x48
	}
	if m.SamplingTryCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.SamplingTryCount))
		i--
		dAtA[i] = 0x40
	}
	if m.PerValidatorRequestGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PerValidatorRequestGas))
		i--
		dAtA[i] = 0x38
	}
	if m.BaseOwasmGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BaseOwasmGas))
		i--
		dAtA[i] = 0x30
	}
	if m.ExpirationBlockCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExpirationBlockCount))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxReportDataSize != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxReportDataSize))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxCalldataSize != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxCalldataSize))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxAskCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxAskCount))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRawRequestCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxRawRequestCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingResolveList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingResolveList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingResolveList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestIds) > 0 {
		dAtA5 := make([]byte, len(m.RequestIds)*10)
		var j4 int
		for _, num := range m.RequestIds {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintOracle(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IBCChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IBCChannel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IBCChannel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestVerification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVerification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVerification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataSourceID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x28
	}
	if m.ExternalID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainID) > 0 {
		i -= len(m.ChainID)
		copy(dAtA[i:], m.ChainID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ChainID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResolveTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x20
	}
	if m.Px != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Px))
		i--
		dAtA[i] = 0x18
	}
	if m.Multiplier != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Multiplier))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OraclePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataProvidersPool) > 0 {
		for iNdEx := len(m.DataProvidersPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataProvidersPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataProviderAccumulatedReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProviderAccumulatedReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProviderAccumulatedReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataProviderReward) > 0 {
		for iNdEx := len(m.DataProviderReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataProviderReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DataProvider) > 0 {
		i -= len(m.DataProvider)
		copy(dAtA[i:], m.DataProvider)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.DataProvider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataProvidersAccumulatedRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProvidersAccumulatedRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProvidersAccumulatedRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccumulatedAmount) > 0 {
		for iNdEx := len(m.AccumulatedAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccumulatedAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CurrentRewardPerByte) > 0 {
		for iNdEx := len(m.CurrentRewardPerByte) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CurrentRewardPerByte[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccumulatedPaymentsForData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccumulatedPaymentsForData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccumulatedPaymentsForData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccumulatedAmount) > 0 {
		for iNdEx := len(m.AccumulatedAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccumulatedAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RewardThreshold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Blocks != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Blocks))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RequestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for iNdEx := len(m.Reports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int {
	offset -= sovOracle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Treasury)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *OracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *RawRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovOracle(uint64(m.ExternalID))
	}
	if m.DataSourceID != 0 {
		n += 1 + sovOracle(uint64(m.DataSourceID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *RawReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovOracle(uint64(m.ExternalID))
	}
	if m.ExitCode != 0 {
		n += 1 + sovOracle(uint64(m.ExitCode))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovOracle(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.RequestedValidators) > 0 {
		for _, s := range m.RequestedValidators {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.MinCount != 0 {
		n += 1 + sovOracle(uint64(m.MinCount))
	}
	if m.RequestHeight != 0 {
		n += 1 + sovOracle(uint64(m.RequestHeight))
	}
	if m.RequestTime != 0 {
		n += 1 + sovOracle(uint64(m.RequestTime))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.RawRequests) > 0 {
		for _, e := range m.RawRequests {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.IBCChannel != nil {
		l = m.IBCChannel.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.ExecuteGas != 0 {
		n += 1 + sovOracle(uint64(m.ExecuteGas))
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.InBeforeResolve {
		n += 2
	}
	if len(m.RawReports) > 0 {
		for _, e := range m.RawReports {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *OracleRequestPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.OracleScriptID != 0 {
		n += 1 + sovOracle(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovOracle(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovOracle(uint64(m.MinCount))
	}
	if len(m.FeeLimit) > 0 {
		for _, e := range m.FeeLimit {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.PrepareGas != 0 {
		n += 1 + sovOracle(uint64(m.PrepareGas))
	}
	if m.ExecuteGas != 0 {
		n += 1 + sovOracle(uint64(m.ExecuteGas))
	}
	return n
}

func (m *OracleRequestPacketAcknowledgement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	return n
}

func (m *OracleResponsePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	if m.AnsCount != 0 {
		n += 1 + sovOracle(uint64(m.AnsCount))
	}
	if m.RequestTime != 0 {
		n += 1 + sovOracle(uint64(m.RequestTime))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovOracle(uint64(m.ResolveTime))
	}
	if m.ResolveStatus != 0 {
		n += 1 + sovOracle(uint64(m.ResolveStatus))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.OracleScriptID != 0 {
		n += 1 + sovOracle(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovOracle(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovOracle(uint64(m.MinCount))
	}
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	if m.AnsCount != 0 {
		n += 1 + sovOracle(uint64(m.AnsCount))
	}
	if m.RequestTime != 0 {
		n += 1 + sovOracle(uint64(m.RequestTime))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovOracle(uint64(m.ResolveTime))
	}
	if m.ResolveStatus != 0 {
		n += 1 + sovOracle(uint64(m.ResolveStatus))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *ValidatorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsActive {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Since)
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *ActiveValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovOracle(uint64(m.Power))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRawRequestCount != 0 {
		n += 1 + sovOracle(uint64(m.MaxRawRequestCount))
	}
	if m.MaxAskCount != 0 {
		n += 1 + sovOracle(uint64(m.MaxAskCount))
	}
	if m.MaxCalldataSize != 0 {
		n += 1 + sovOracle(uint64(m.MaxCalldataSize))
	}
	if m.MaxReportDataSize != 0 {
		n += 1 + sovOracle(uint64(m.MaxReportDataSize))
	}
	if m.ExpirationBlockCount != 0 {
		n += 1 + sovOracle(uint64(m.ExpirationBlockCount))
	}
	if m.BaseOwasmGas != 0 {
		n += 1 + sovOracle(uint64(m.BaseOwasmGas))
	}
	if m.PerValidatorRequestGas != 0 {
		n += 1 + sovOracle(uint64(m.PerValidatorRequestGas))
	}
	if m.SamplingTryCount != 0 {
		n += 1 + sovOracle(uint64(m.SamplingTryCount))
	}
	if m.OracleRewardPercentage != 0 {
		n += 1 + sovOracle(uint64(m.OracleRewardPercentage))
	}
	if m.InactivePenaltyDuration != 0 {
		n += 1 + sovOracle(uint64(m.InactivePenaltyDuration))
	}
	if m.IBCRequestEnabled {
		n += 2
	}
	if len(m.DataProviderRewardPerByte) > 0 {
		for _, e := range m.DataProviderRewardPerByte {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	l = m.DataProviderRewardThreshold.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.RewardDecreasingFraction.Size()
	n += 1 + l + sovOracle(uint64(l))
	if len(m.DataRequesterFeeDenoms) > 0 {
		for _, s := range m.DataRequesterFeeDenoms {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *PendingResolveList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestIds) > 0 {
		l = 0
		for _, e := range m.RequestIds {
			l += sovOracle(uint64(e))
		}
		n += 1 + sovOracle(uint64(l)) + l
	}
	return n
}

func (m *IBCChannel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *RequestVerification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	if m.ExternalID != 0 {
		n += 1 + sovOracle(uint64(m.ExternalID))
	}
	if m.DataSourceID != 0 {
		n += 1 + sovOracle(uint64(m.DataSourceID))
	}
	return n
}

func (m *PriceResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Multiplier != 0 {
		n += 1 + sovOracle(uint64(m.Multiplier))
	}
	if m.Px != 0 {
		n += 1 + sovOracle(uint64(m.Px))
	}
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovOracle(uint64(m.ResolveTime))
	}
	return n
}

func (m *OraclePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataProvidersPool) > 0 {
		for _, e := range m.DataProvidersPool {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *DataProviderAccumulatedReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataProvider)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.DataProviderReward) > 0 {
		for _, e := range m.DataProviderReward {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *DataProvidersAccumulatedRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CurrentRewardPerByte) > 0 {
		for _, e := range m.CurrentRewardPerByte {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if len(m.AccumulatedAmount) > 0 {
		for _, e := range m.AccumulatedAmount {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *AccumulatedPaymentsForData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AccumulatedAmount) > 0 {
		for _, e := range m.AccumulatedAmount {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *RewardThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.Blocks != 0 {
		n += 1 + sovOracle(uint64(m.Blocks))
	}
	return n
}

func (m *RequestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.Reports) > 0 {
		for _, e := range m.Reports {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func sovOracle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOracle(x uint64) (n int) {
	return sovOracle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Treasury = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedValidators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedValidators = append(m.RequestedValidators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeight", wireType)
			}
			m.RequestHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRequests = append(m.RawRequests, RawRequest{})
			if err := m.RawRequests[len(m.RawRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBCChannel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IBCChannel == nil {
				m.IBCChannel = &IBCChannel{}
			}
			if err := m.IBCChannel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteGas", wireType)
			}
			m.ExecuteGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBeforeResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InBeforeResolve = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawReports = append(m.RawReports, RawReport{})
			if err := m.RawReports[len(m.RawReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleRequestPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeLimit = append(m.FeeLimit, types.Coin{})
			if err := m.FeeLimit[len(m.FeeLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareGas", wireType)
			}
			m.PrepareGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrepareGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteGas", wireType)
			}
			m.ExecuteGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleRequestPacketAcknowledgement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestPacketAcknowledgement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestPacketAcknowledgement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleResponsePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleResponsePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleResponsePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsCount", wireType)
			}
			m.AnsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveStatus", wireType)
			}
			m.ResolveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveStatus |= ResolveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsCount", wireType)
			}
			m.AnsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveStatus", wireType)
			}
			m.ResolveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveStatus |= ResolveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Since, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRawRequestCount", wireType)
			}
			m.MaxRawRequestCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRawRequestCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAskCount", wireType)
			}
			m.MaxAskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCalldataSize", wireType)
			}
			m.MaxCalldataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCalldataSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReportDataSize", wireType)
			}
			m.MaxReportDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReportDataSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationBlockCount", wireType)
			}
			m.ExpirationBlockCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationBlockCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseOwasmGas", wireType)
			}
			m.BaseOwasmGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseOwasmGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerValidatorRequestGas", wireType)
			}
			m.PerValidatorRequestGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerValidatorRequestGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingTryCount", wireType)
			}
			m.SamplingTryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SamplingTryCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleRewardPercentage", wireType)
			}
			m.OracleRewardPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleRewardPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactivePenaltyDuration", wireType)
			}
			m.InactivePenaltyDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactivePenaltyDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBCRequestEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IBCRequestEnabled = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProviderRewardPerByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProviderRewardPerByte = append(m.DataProviderRewardPerByte, types.Coin{})
			if err := m.DataProviderRewardPerByte[len(m.DataProviderRewardPerByte)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProviderRewardThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataProviderRewardThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDecreasingFraction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardDecreasingFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRequesterFeeDenoms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRequesterFeeDenoms = append(m.DataRequesterFeeDenoms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingResolveList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingResolveList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingResolveList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOracle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequestIds = append(m.RequestIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOracle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOracle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOracle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RequestIds) == 0 {
					m.RequestIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOracle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequestIds = append(m.RequestIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IBCChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IBCChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IBCChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVerification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVerification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVerification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			m.Multiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiplier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Px", wireType)
			}
			m.Px = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Px |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProvidersPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProvidersPool = append(m.DataProvidersPool, types.Coin{})
			if err := m.DataProvidersPool[len(m.DataProvidersPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProviderAccumulatedReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProviderAccumulatedReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProviderAccumulatedReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProviderReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProviderReward = append(m.DataProviderReward, types.Coin{})
			if err := m.DataProviderReward[len(m.DataProviderReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProvidersAccumulatedRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProvidersAccumulatedRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProvidersAccumulatedRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRewardPerByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentRewardPerByte = append(m.CurrentRewardPerByte, types.Coin{})
			if err := m.CurrentRewardPerByte[len(m.CurrentRewardPerByte)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccumulatedAmount = append(m.AccumulatedAmount, types.Coin{})
			if err := m.AccumulatedAmount[len(m.AccumulatedAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccumulatedPaymentsForData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccumulatedPaymentsForData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccumulatedPaymentsForData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccumulatedAmount = append(m.AccumulatedAmount, types.Coin{})
			if err := m.AccumulatedAmount[len(m.AccumulatedAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardThreshold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardThreshold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardThreshold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			m.Blocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Blocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &Request{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reports = append(m.Reports, Report{})
			if err := m.Reports[len(m.Reports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOracle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOracle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOracle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOracle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
